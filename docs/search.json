[{"path":"https://fbertran.github.io/bigPCAcpp/articles/bigPCA-benchmarks.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Benchmarking bigPCAcpp Workflows","text":"vignette summarises performance principal component analysis (PCA) routines provided bigPCAcpp across matrices ranging small large dimensions. experiments operate -memory [bigmemory::big.matrix] objects avoid file-backed storage baseline using base R’s [stats::prcomp()] included context. benchmarking code executed , resulting dataset stored package benchmark_results. analysis relies exclusively saved dataset vignette can built quickly.","code":"data(\"benchmark_results\", package = \"bigPCAcpp\") str(benchmark_results) #> 'data.frame':    360 obs. of  14 variables: #>  $ dataset    : chr  \"small\" \"small\" \"small\" \"small\" ... #>  $ rows       : int  1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 ... #>  $ cols       : int  50 50 50 50 50 50 50 50 50 50 ... #>  $ ncomp      : int  10 10 10 10 10 10 10 10 10 10 ... #>  $ method     : chr  \"classical\" \"classical\" \"classical\" \"classical\" ... #>  $ replicate  : int  1 2 3 4 5 6 7 8 9 10 ... #>  $ user_time  : num  0.003 0.003 0.002 0.002 0.002 ... #>  $ system_time: num  0.001 0 0 0 0 0 0 0 0 0 ... #>  $ elapsed    : num  0.003 0.002 0.002 0.002 0.002 ... #>  $ success    : logi  TRUE TRUE TRUE TRUE TRUE TRUE ... #>  $ backend    : chr  \"bigmemory\" \"bigmemory\" \"bigmemory\" \"bigmemory\" ... #>  $ iterations : int  NA NA NA NA NA NA NA NA NA NA ... #>  $ converged  : logi  NA NA NA NA NA NA ... #>  $ error      : chr  NA NA NA NA ..."},{"path":"https://fbertran.github.io/bigPCAcpp/articles/bigPCA-benchmarks.html","id":"how-the-benchmarks-were-produced","dir":"Articles","previous_headings":"","what":"How the benchmarks were produced","title":"Benchmarking bigPCAcpp Workflows","text":"following chunk outlines code generated stored results. chunk evaluated building vignette keep compilation times short, can used reproduce dataset manually.","code":"suppressPackageStartupMessages({   library(bigmemory)   if (requireNamespace(\"bigPCAcpp\", quietly = TRUE)) {     library(bigPCAcpp)   } else {     if (!requireNamespace(\"pkgload\", quietly = TRUE)) {       stop(\"bigPCAcpp must be installed or pkgload must be available\", call. = FALSE)     }     pkgload::load_all(\".\")   } })  sizes <- list(   small = list(rows = 1000L, cols = 50L),   medium = list(rows = 5000L, cols = 100L),   large = list(rows = 20000L, cols = 200L),   xlarge = list(rows = 50000L, cols = 300L),   xxlarge = list(rows = 100000L, cols = 500L),   xxxlarge = list(rows = 100000L, cols = 2000L) )  method_runners <- list(   classical = function(mats, ncomp) {     pca_bigmatrix(mats$big, center = TRUE, scale = TRUE, ncomp = ncomp)   },   streaming = function(mats, ncomp) {     pca_stream_bigmatrix(mats$big, center = TRUE, scale = TRUE, ncomp = ncomp)   },   scalable = function(mats, ncomp) {     pca_spca(       mats$big,       ncomp = ncomp,       center = TRUE,       scale = TRUE,       block_size = 2048L,       max_iter = 25L,       tol = 1e-4,       seed = 42L,       return_scores = FALSE,       verbose = FALSE     )   },   prcomp = function(mats, ncomp) {     stats::prcomp(       mats$dense,       center = TRUE,       scale. = TRUE,       rank. = ncomp     )   } )  replicates_for <- function(rows) {   if (rows <= 5000L) {     20L   } else if (rows <= 20000L) {     20L   } else {     10L   } }  results <- list() row_id <- 1L set.seed(123)  for (dataset_name in names(sizes)) {   dims <- sizes[[dataset_name]]   message(sprintf(\"Generating dataset '%s' with %d rows and %d columns\", dataset_name, dims$rows, dims$cols))   mat <- matrix(rnorm(dims$rows * dims$cols), nrow = dims$rows, ncol = dims$cols)   big_mat <- bigmemory::as.big.matrix(mat, type = \"double\")   ncomp <- min(10L, dims$cols)   reps <- replicates_for(dims$rows)   inputs <- list(dense = mat, big = big_mat)      for (method_name in names(method_runners)) {     runner <- method_runners[[method_name]]     for (rep in seq_len(reps)) {       gc()       gc()       message(sprintf(\"Running %s (replicate %d/%d) on %s\", method_name, rep, reps, dataset_name))       res <- NULL       timing <- system.time({         res <<- tryCatch(           runner(inputs, ncomp),           error = function(e) e         )       })       success <- !inherits(res, \"error\")       backend <- if (success) {         backend_val <- attr(res, \"backend\", exact = TRUE)         if (is.null(backend_val) && !is.null(res$backend)) {           res$backend         } else {           backend_val         }       } else {         NA_character_       }       iterations <- if (success) {         iter <- attr(res, \"iterations\", exact = TRUE)         if (is.null(iter)) NA_integer_ else as.integer(iter)       } else {         NA_integer_       }       converged <- if (success) {         conv <- attr(res, \"converged\", exact = TRUE)         if (is.null(conv)) NA else as.logical(conv)       } else {         NA       }       results[[row_id]] <- data.frame(         dataset = dataset_name,         rows = dims$rows,         cols = dims$cols,         ncomp = ncomp,         method = method_name,         replicate = rep,         user_time = unname(timing[[\"user.self\"]]),         system_time = unname(timing[[\"sys.self\"]]),         user_time = unname(timing[[\"user_time\"]]),         success = success,         backend = if (is.null(backend)) NA_character_ else as.character(backend),         iterations = iterations,         converged = converged,         error = if (success) NA_character_ else conditionMessage(res),         stringsAsFactors = FALSE       )       row_id <- row_id + 1L     }   }   rm(mat, big_mat)   gc()   gc() }  benchmark_results <- do.call(rbind, results)  if (!dir.exists(\"data\")) {   dir.create(\"data\") }  save(benchmark_results, file = file.path(\"data\", \"benchmark_results.rda\"), compress = \"bzip2\")"},{"path":"https://fbertran.github.io/bigPCAcpp/articles/bigPCA-benchmarks.html","id":"summary-statistics","dir":"Articles","previous_headings":"","what":"Summary statistics","title":"Benchmarking bigPCAcpp Workflows","text":"successful runs retained summaries. Replicate counts vary matrix size (twenty runs matrices 20,000 rows tens runs). user_time time summaries (seconds) dataset size method. user_time time summaries (seconds) dataset size method.","code":"successful <- benchmark_results[benchmark_results$success, ] method_levels <- c(\"prcomp\", \"classical\", \"streaming\", \"scalable\") successful$method <- factor(successful$method, levels = method_levels, ordered = TRUE) mean_user_time <- aggregate(user_time ~ dataset + method, successful, mean) colnames(mean_user_time)[colnames(mean_user_time) == \"user_time\"] <- \"mean_user_time\"  sd_user_time <- aggregate(user_time ~ dataset + method, successful, sd) colnames(sd_user_time)[colnames(sd_user_time) == \"user_time\"] <- \"sd_user_time\"  rep_counts <- aggregate(replicate ~ dataset + method, successful, length) colnames(rep_counts)[colnames(rep_counts) == \"replicate\"] <- \"n_runs\"  summary_table <- Reduce(   function(x, y) merge(x, y, by = c(\"dataset\", \"method\"), all = TRUE),   list(mean_user_time, sd_user_time, rep_counts) )  summary_table$sd_user_time[summary_table$n_runs <= 1] <- NA_real_ summary_table$method <- factor(summary_table$method, levels = method_levels)  mean_user_time$dataset <- factor(mean_user_time$dataset,levels = c(\"small\", \"medium\", \"large\", \"xlarge\", \"xxlarge\", \"xxxlarge\"),ordered = TRUE)  summary_table <- summary_table[order(summary_table$dataset,summary_table$method),] knitr::kable(   summary_table,   digits = 3,   caption = \"user_time time summaries (seconds) by dataset size and method.\" ) summary_table2 <- summary_table[order(summary_table$method,summary_table$dataset),] knitr::kable(   summary_table2,   digits = 3,   caption = \"user_time time summaries (seconds) by dataset size and method.\" )"},{"path":"https://fbertran.github.io/bigPCAcpp/articles/bigPCA-benchmarks.html","id":"visual-comparison","dir":"Articles","previous_headings":"","what":"Visual comparison","title":"Benchmarking bigPCAcpp Workflows","text":"plot compares average elapsed user time method across simulated datasets. Error bars denote one standard deviation multiple replicates available.  Without prcomp baseline zoom results three algorithms.","code":"if (requireNamespace(\"ggplot2\", quietly = TRUE)) {   library(ggplot2)   plot_data <- summary_table   plot_data$dataset <- factor(plot_data$dataset, levels = c(\"small\", \"medium\", \"large\", \"xlarge\", \"xxlarge\", \"xxxlarge\"),ordered = TRUE)   plot_data$method <- factor(plot_data$method, levels = method_levels)    ggplot(plot_data, aes(x = dataset, y = mean_user_time, colour = method, group = method)) +     geom_line() +     geom_point(size = 2) +     geom_errorbar(       aes(ymin = mean_user_time - sd_user_time, ymax = mean_user_time + sd_user_time),       width = 0.1,       na.rm = TRUE     ) +     labs(       x = \"Dataset size\",       y = \"Mean user_time time (s)\",       colour = \"Method\",       title = \"Performance of bigPCAcpp PCA routines\",       subtitle = \"All benchmarks run on in-memory big.matrix objects\"     ) +     theme_minimal()        ggplot(plot_data, aes(x = method, y = mean_user_time, colour = dataset, group = dataset)) +     geom_line() +     geom_point(size = 2) +     geom_errorbar(       aes(ymin = mean_user_time - sd_user_time, ymax = mean_user_time + sd_user_time),       width = 0.1,       na.rm = TRUE     ) +     labs(       x = \"Dataset size\",       y = \"Mean user_time time (s)\",       colour = \"Method\",       title = \"Performance of bigPCAcpp PCA routines\",       subtitle = \"All benchmarks run on in-memory big.matrix objects\"     ) +     theme_minimal() } else {   message(\"ggplot2 is not installed; skipping the benchmark plot.\") } if (requireNamespace(\"ggplot2\", quietly = TRUE)) {   library(ggplot2)   plot_data <- subset(summary_table, summary_table$method!=\"prcomp\")   plot_data$dataset <- factor(plot_data$dataset, levels = c(\"small\", \"medium\", \"large\", \"xlarge\", \"xxlarge\", \"xxxlarge\"),ordered = TRUE)   plot_data$method <- factor(plot_data$method, levels = method_levels)    ggplot(plot_data, aes(x = dataset, y = mean_user_time, colour = method, group = method)) +     geom_line() +     geom_point(size = 2) +     geom_errorbar(       aes(ymin = mean_user_time - sd_user_time, ymax = mean_user_time + sd_user_time),       width = 0.1,       na.rm = TRUE     ) +     labs(       x = \"Dataset size\",       y = \"Mean user_time time (s)\",       colour = \"Method\",       title = \"Performance of bigPCAcpp PCA routines\",       subtitle = \"All benchmarks run on in-memory big.matrix objects\"     ) +     theme_minimal()        ggplot(plot_data, aes(x = method, y = mean_user_time, colour = dataset, group = dataset)) +     geom_line() +     geom_point(size = 2) +     geom_errorbar(       aes(ymin = mean_user_time - sd_user_time, ymax = mean_user_time + sd_user_time),       width = 0.1,       na.rm = TRUE     ) +     labs(       x = \"Dataset size\",       y = \"Mean user_time time (s)\",       colour = \"Method\",       title = \"Performance of bigPCAcpp PCA routines\",       subtitle = \"All benchmarks run on in-memory big.matrix objects\"     ) +     theme_minimal() } else {   message(\"ggplot2 is not installed; skipping the benchmark plot.\") }"},{"path":"https://fbertran.github.io/bigPCAcpp/articles/bigPCA-benchmarks.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Benchmarking bigPCAcpp Workflows","text":"","code":"sessionInfo() #> R version 4.5.0 (2025-04-11) #> Platform: aarch64-apple-darwin20 #> Running under: macOS Sonoma 14.7.1 #>  #> Matrix products: default #> BLAS:   /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRblas.0.dylib  #> LAPACK: /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.1 #>  #> locale: #> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 #>  #> time zone: Europe/Paris #> tzcode source: internal #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] ggplot2_4.0.0 #>  #> loaded via a namespace (and not attached): #>  [1] gtable_0.3.6       jsonlite_2.0.0     dplyr_1.1.4        compiler_4.5.0     #>  [5] tidyselect_1.2.1   jquerylib_0.1.4    systemfonts_1.2.3  scales_1.4.0       #>  [9] textshaping_1.0.3  yaml_2.3.10        fastmap_1.2.0      R6_2.6.1           #> [13] labeling_0.4.3     generics_0.1.4     knitr_1.50         htmlwidgets_1.6.4  #> [17] tibble_3.3.0       desc_1.4.3         bslib_0.9.0        pillar_1.11.0      #> [21] RColorBrewer_1.1-3 rlang_1.1.6        cachem_1.1.0       xfun_0.53          #> [25] fs_1.6.6           sass_0.4.10        S7_0.2.0           viridisLite_0.4.2  #> [29] cli_3.6.5          pkgdown_2.1.3      withr_3.0.2        magrittr_2.0.4     #> [33] digest_0.6.37      grid_4.5.0         rstudioapi_0.17.1  lifecycle_1.0.4    #> [37] vctrs_0.6.5        evaluate_1.0.5     glue_1.8.0         farver_2.1.2       #> [41] ragg_1.5.0         rmarkdown_2.29     tools_4.5.0        pkgconfig_2.0.3    #> [45] htmltools_0.5.8.1"},{"path":"https://fbertran.github.io/bigPCAcpp/articles/bigPCAcpp.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Fast Principal Component Analysis for Big Data with bigPCAcpp","text":"bigPCAcpp package provides principal component analysis (PCA) routines operate directly bigmemory::big.matrix objects. vignette walks complete analysis workflow compares results reference implementation base R’s prcomp() demonstrate numerical agreement. use classic iris measurement data small, -memory example. Even larger data sets stored disk, workflow identical big.matrix descriptor created.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/articles/bigPCAcpp.html","id":"preparing-a-big-matrix","dir":"Articles","previous_headings":"","what":"Preparing a big.matrix","title":"Fast Principal Component Analysis for Big Data with bigPCAcpp","text":"Every bigPCAcpp entry point accepts big.matrix object directly (, compatibility, still works external pointers via @address slot), allowing analyses without copying data regular R matrices.","code":"library(bigmemory) library(bigPCAcpp)  iris_mat <- as.matrix(iris[, 1:4]) big_iris <- as.big.matrix(iris_mat, type = \"double\")"},{"path":"https://fbertran.github.io/bigPCAcpp/articles/bigPCAcpp.html","id":"running-pca-with-bigpcacpp","dir":"Articles","previous_headings":"","what":"Running PCA with bigPCAcpp","title":"Fast Principal Component Analysis for Big Data with bigPCAcpp","text":"returned list mirrors structure prcomp object: singular values (sdev), rotation matrix (rotation), optional centering scaling vectors, additional diagnostics including covariance matrix explained variance ratios.","code":"big_pca <- pca_bigmatrix(   xpMat = big_iris,   center = TRUE,   scale = TRUE,   ncomp = 4L,   block_size = 128L ) str(big_pca) #> List of 10 #>  $ sdev               : num [1:4] 1.708 0.956 0.383 0.144 #>  $ rotation           : num [1:4, 1:4] 0.521 -0.269 0.58 0.565 0.377 ... #>  $ center             : num [1:4] 5.84 3.06 3.76 1.2 #>  $ scale              : num [1:4] 0.828 0.436 1.765 0.762 #>  $ column_sd          : num [1:4] 0.828 0.436 1.765 0.762 #>  $ eigenvalues        : num [1:4] 2.9185 0.914 0.1468 0.0207 #>  $ explained_variance : num [1:4] 0.72962 0.22851 0.03669 0.00518 #>  $ cumulative_variance: num [1:4] 0.73 0.958 0.995 1 #>  $ covariance         : num [1:4, 1:4] 1 -0.118 0.872 0.818 -0.118 ... #>  $ nobs               : num 150 #>  - attr(*, \"backend\")= chr \"bigmemory\" #>  - attr(*, \"class\")= chr [1:3] \"bigpca_bigmemory\" \"bigpca\" \"list\""},{"path":"https://fbertran.github.io/bigPCAcpp/articles/bigPCAcpp.html","id":"comparing-against-prcomp","dir":"Articles","previous_headings":"","what":"Comparing against prcomp","title":"Fast Principal Component Analysis for Big Data with bigPCAcpp","text":"maximum absolute deviations base implementation bigPCAcpp negligible (order numerical precision), showing --core algorithm faithfully reproduces components scores.","code":"base_pca <- prcomp(iris_mat, center = TRUE, scale. = TRUE)  align_columns <- function(reference, target) {   aligned <- target   cols <- min(ncol(reference), ncol(target))   for (j in seq_len(cols)) {     ref <- reference[, j]     tgt <- target[, j]     if (sum((ref - tgt)^2) > sum((ref + tgt)^2)) {       aligned[, j] <- -tgt     }   }   aligned }  rotation_aligned <- align_columns(base_pca$rotation, big_pca$rotation) max_rotation_error <- max(abs(rotation_aligned - base_pca$rotation)) max_sdev_error <- max(abs(big_pca$sdev - base_pca$sdev))  big_scores <- pca_scores_bigmatrix(   xpMat = big_iris,   rotation = big_pca$rotation,   center = big_pca$center,   scale = big_pca$scale,   block_size = 128L )  scores_aligned <- align_columns(base_pca$x, big_scores) max_score_error <- max(abs(scores_aligned - base_pca$x))  c(   rotation = max_rotation_error,   sdev = max_sdev_error,   scores = max_score_error ) #>     rotation         sdev       scores  #> 3.441691e-15 1.110223e-15 7.993606e-15"},{"path":"https://fbertran.github.io/bigPCAcpp/articles/bigPCAcpp.html","id":"variable-relationships","dir":"Articles","previous_headings":"","what":"Variable relationships","title":"Fast Principal Component Analysis for Big Data with bigPCAcpp","text":"exported helpers expose common PCA diagnostics without requiring original data matrix memory. Loadings match scaled rotation matrix, correlations honour whether PCA computed standardised variables remain bounded -1 1, contributions report relative importance variable within component.","code":"loadings <- pca_variable_loadings(big_pca$rotation, big_pca$sdev) correlations <- pca_variable_correlations(   big_pca$rotation,   big_pca$sdev,   big_pca$column_sd,   big_pca$scale ) contributions <- pca_variable_contributions(loadings)  head(loadings) #>            [,1]       [,2]        [,3]        [,4] #> [1,]  0.8901688 0.36082989  0.27565767 -0.03760602 #> [2,] -0.4601427 0.88271627 -0.09361987  0.01777631 #> [3,]  0.9915552 0.02341519 -0.05444699  0.11534978 #> [4,]  0.9649790 0.06399985 -0.24298265 -0.07535950 head(correlations) #>            [,1]       [,2]        [,3]        [,4] #> [1,]  0.8901688 0.36082989  0.27565767 -0.03760602 #> [2,] -0.4601427 0.88271627 -0.09361987  0.01777631 #> [3,]  0.9915552 0.02341519 -0.05444699  0.11534978 #> [4,]  0.9649790 0.06399985 -0.24298265 -0.07535950 head(contributions) #>            [,1]         [,2]       [,3]       [,4] #> [1,] 0.27150969 0.1424440565 0.51777574 0.06827052 #> [2,] 0.07254804 0.8524748749 0.05972245 0.01525463 #> [3,] 0.33687936 0.0005998389 0.02019990 0.64232089 #> [4,] 0.31906291 0.0044812296 0.40230191 0.27415396 range(correlations) #> [1] -0.4601427  0.9915552"},{"path":"https://fbertran.github.io/bigPCAcpp/articles/bigPCAcpp.html","id":"visualising-pca-results","dir":"Articles","previous_headings":"","what":"Visualising PCA results","title":"Fast Principal Component Analysis for Big Data with bigPCAcpp","text":"companion plotting helpers make straightforward inspect components returned bigPCAcpp. Scree plot variance explained component. scree plot summarises much variance component explains makes easy identify natural cutoffs. Scores first two principal components. Score plots provide quick way compare sample relationships using requested principal components without materialising full score matrix. Correlation circle highlighting variables align first two components. Correlation circles visualise variable aligns chosen components, making easy spot groups features contribute similar direction. Biplot combining sample scores variable loadings. biplot overlays sample scores variable loadings, providing joint view observations cluster along selected components features drive separations.","code":"pca_plot_scree(big_pca) pca_plot_scores(   big_iris,   rotation = big_pca$rotation,   center = big_pca$center,   scale = big_pca$scale,   max_points = nrow(big_iris),   sample = \"head\" ) pca_plot_correlation_circle(   correlations,   components = c(1L, 2L) ) pca_plot_biplot(   big_scores,   loadings,   components = c(1L, 2L) )"},{"path":"https://fbertran.github.io/bigPCAcpp/articles/bigPCAcpp.html","id":"singular-value-decomposition-helpers","dir":"Articles","previous_headings":"","what":"Singular value decomposition helpers","title":"Fast Principal Component Analysis for Big Data with bigPCAcpp","text":"package also exposes building blocks singular value decomposition (SVD) operate directly big.matrix instances, can useful custom pipelines need singular vectors values. svd_bigmatrix() helper mirrors base R’s svd() streams data manageable blocks, making practical large file-backed matrices.","code":"svd_res <- svd_bigmatrix(big_iris, nu = 2L, nv = 2L, block_size = 128L) svd_res$d #> [1] 95.959914 17.761034  3.460931  1.884826"},{"path":"https://fbertran.github.io/bigPCAcpp/articles/bigPCAcpp.html","id":"robust-pca-and-svd","dir":"Articles","previous_headings":"","what":"Robust PCA and SVD","title":"Fast Principal Component Analysis for Big Data with bigPCAcpp","text":"data contain outliers, robust variants supplied bigPCAcpp help stabilise recovered components -weighting leverage points. robust PCA interface accepts regular dense matrices, computes robust estimates location scale, returns component scores along per-row weights iteration counts used re-weighted SVD. underlying solver also exposed directly bespoke workflows need robust singular value decomposition. robust SVD returns singular values, left singular vectors, weights assigned observation, can combined classical SVD results assess influence individual rows.","code":"robust_pca <- pca_robust(iris_mat, ncomp = 4L) robust_pca$sdev #> [1] 1.9153872 0.5075338 0.3074052 0.2357631 robust_pca$robust_weights[1:10] #>  [1] 0.02469728 0.07676234 0.43335242 0.67140174 0.67743015 0.74308617 #>  [7] 0.65577512 0.74857591 0.79772190 0.68421285 robust_svd <- svd_robust(iris_mat, ncomp = 3L) robust_svd$d #> [1] 85.31120 16.25951  3.14779 robust_svd$weights[1:10] #>  [1] 1 1 1 1 1 1 1 1 1 1"},{"path":"https://fbertran.github.io/bigPCAcpp/articles/bigPCAcpp.html","id":"next-steps-for-larger-data","dir":"Articles","previous_headings":"","what":"Next steps for larger data","title":"Fast Principal Component Analysis for Big Data with bigPCAcpp","text":"-disk matrices created filebacked.big.matrix(), pass descriptor pointer pca_bigmatrix() algorithm stream data blocks, keeping memory usage bounded. Component scores can likewise generated batches using pca_scores_stream_bigmatrix(). scores stored disk, can sampled plotted just like -memory workflow: Scores streamed file-backed big.matrix. building blocks, bigPCAcpp enables analyses match accuracy -memory PCA workflows scaling data sets exceed RAM.","code":"library(bigmemory) library(bigPCAcpp)  path <- tempfile(fileext = \".bin\") desc <- paste0(path, \".desc\")  bm <- filebacked.big.matrix(   nrow = nrow(iris_mat),   ncol = ncol(iris_mat),   type = \"double\",   backingfile = basename(path),   backingpath = dirname(path),   descriptorfile = basename(desc) )  bm[,] <- iris_mat  pca <- pca_bigmatrix(bm, center = TRUE, scale = TRUE, ncomp = 4) scores <- filebacked.big.matrix(   nrow = nrow(bm),   ncol = ncol(pca$rotation),   type = \"double\",   backingfile = \"scores.bin\",   backingpath = dirname(path),   descriptorfile = \"scores.desc\" )  pca_scores_stream_bigmatrix(   bm,   scores,   pca$rotation,   center = pca$center,   scale = pca$scale ) #> <pointer: 0x1507a2210> pca_plot_scores(   bm,   rotation = pca$rotation,   center = pca$center,   scale = pca$scale,   components = c(1L, 2L),   max_points = nrow(bm),   sample = \"head\" ) library(bigmemory) library(bigPCAcpp)  path <- tempfile(fileext = \".bin\") desc <- paste0(path, \".desc\")  bm <- filebacked.big.matrix(   nrow = 5000,   ncol = 50,   type = \"double\",   backingfile = basename(path),   backingpath = dirname(path),   descriptorfile = basename(desc) )  pca <- pca_bigmatrix(bm, center = TRUE, scale = TRUE, ncomp = 5) scores <- filebacked.big.matrix(   nrow = nrow(bm),   ncol = ncol(pca$rotation),   type = \"double\",   backingfile = \"scores.bin\",   backingpath = dirname(path),   descriptorfile = \"scores.desc\" )  pca_scores_stream_bigmatrix(   bm,   scores,   pca$rotation,   center = pca$center,   scale = pca$scale )"},{"path":"https://fbertran.github.io/bigPCAcpp/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Frederic Bertrand. Author, maintainer.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Frédéric Bertrand (2025). Principal Component Analysis 'bigmemory' Matrices, R package version 0.9.0.","code":"@Manual{,   title = {Principal Component Analysis for 'bigmemory' Matrices},   author = {Frederic Bertrand},   year = {2025},   note = {R package version 0.9.0}, }"},{"path":[]},{"path":[]},{"path":"https://fbertran.github.io/bigPCAcpp/index.html","id":"frédéric-bertrand","dir":"","previous_headings":"","what":"Frédéric Bertrand","title":"Principal Component Analysis for bigmemory Matrices","text":"bigPCAcpp package provides high performance principal component analysis (PCA) routines specialised bigmemory::big.matrix objects. keeps data bigmemory allocations ingestion eigendecomposition large matrices can analysed without copying base R matrices. addition PCA core, package offers streaming helpers write scores, loadings, correlations, contributions back file-backed big.matrix targets integration downstream pipelines. Beyond classical PCA, package ships scalable SVD tools can process file-backed matrices block block, includes robust PCA robust SVD routines temper influence outliers remaining compatible bigmemory workflows. exploratory work large batches, scalable PCA interface lets users extract leading components without reading full matrix memory. workflows make possible analyse data sets exceed available RAM keeping numerical stability double-precision accumulation LAPACK eigen decompositions. Current features include centring scaling directly big.matrix inputs, incremental score generation avoids bringing data memory, helpers persist PCA diagnostics file-backed storage, SVD utilities dense robust decompositions backed bigmemory, ","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Principal Component Analysis for bigmemory Matrices","text":"can install development version bigPCAcpp GitHub : prefer local source install, clone repository run:","code":"# install.packages(\"devtools\") devtools::install_github(\"fbertran/bigPCAcpp\") R CMD build bigPCAcpp R CMD INSTALL bigPCAcpp_0.9.0.tar.gz"},{"path":"https://fbertran.github.io/bigPCAcpp/index.html","id":"options","dir":"","previous_headings":"","what":"Options","title":"Principal Component Analysis for bigmemory Matrices","text":"package defines several options control numerical tolerances workspace allocation. prefixed bigPCAcpp. include: options can changed options() runtime. example, options(bigPCAcpp.block_size = 5000L) increases streaming block size.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/index.html","id":"examples","dir":"","previous_headings":"","what":"Examples","title":"Principal Component Analysis for bigmemory Matrices","text":"examples demonstrate bigmemory workflow compare results base R’s prcomp() implementation. pca_bigmatrix() can also focus subset leading components streaming results file-backed matrices. following snippet stores first four principal components keeps running summary scores. stream diagnostics bigmemory-backed matrices, use corresponding helper functions:","code":"library(bigmemory) library(bigPCAcpp)  # Allocate a 1,000 x 25 big.matrix with simulated values n <- 1000 p <- 25 bm <- bigmemory::big.matrix(n, p, type = \"double\") bm[,] <- matrix(rnorm(n * p), nrow = n)  # Run PCA and extract eigenvalues and rotation res <- pca_bigmatrix(bm, center = TRUE, scale = TRUE) res$eigenvalues #>  [1] 1.2701077 1.2537526 1.2151939 1.2024274 1.1802276 1.1354639 1.1048690 #>  [8] 1.0902075 1.0630117 1.0403948 1.0224523 1.0122884 0.9931732 0.9852838 #> [15] 0.9550143 0.9414302 0.9204860 0.9008016 0.8898188 0.8773914 0.8437966 #> [22] 0.7979435 0.7821215 0.7628152 0.7595271 res$importance #> NULL res$rotation[1:5, 1:3] #>             [,1]        [,2]        [,3] #> [1,]  0.14398208  0.22870330  0.12242692 #> [2,] -0.07237026 -0.21951399  0.19761877 #> [3,] -0.32741500 -0.34723923 -0.02282739 #> [4,]  0.23671229  0.14764528  0.05672112 #> [5,]  0.14343191  0.03490776  0.10010376  # Generate PCA scores in bigmemory storage scores <- bigmemory::big.matrix(   nrow = n,   ncol = 3,   type = \"double\" )  (pca_scores_bigmatrix(   bm,   res$rotation,   center = res$center,   scale = res$scale ))[1:6,1:6] #>             [,1]       [,2]       [,3]       [,4]        [,5]         [,6] #> [1,]  0.65907229 -0.1974698 -3.5714713 -0.7150943  0.01412313  0.519975663 #> [2,] -0.20615917  2.6536525 -2.1246929 -0.2443652 -1.22009504  0.338157676 #> [3,]  1.97067655 -0.1459897  0.2706729 -2.5778456  1.03548532  1.343923490 #> [4,] -0.06521853 -0.3507049 -0.7159949  0.2779695  1.08616408 -1.106634062 #> [5,]  0.34681884  0.6974558 -2.4466572 -0.4696698  1.95794498 -0.008496806 #> [6,]  0.62390402 -0.9625778 -0.9364008  1.5785386  0.47807633  0.074748751  # Compare sum of absolute values with prcomp() pr <- prcomp(bm[], center = TRUE, scale = TRUE) sum(abs(abs(pr$rotation[, 1:3])-abs(res$rotation[, 1:3])))<10^(-6) #> [1] TRUE library(bigmemory) library(bigPCAcpp)  set.seed(2025) bm <- bigmemory::big.matrix(nrow = 1500, ncol = 40, type = \"double\") bm[,] <- matrix(rnorm(1500 * 40), nrow = 1500)  # Request only the first four components top_pca <- pca_bigmatrix(bm, center = TRUE, scale = TRUE, ncomp = 4) top_pca$sdev #> [1] 1.141546 1.124998 1.119607 1.109924  # Stream the corresponding scores into a file-backed allocation path <- tempfile(fileext = \".bin\") desc <- paste0(path, \".desc\")  scores_fb <- bigmemory::filebacked.big.matrix(nrow = nrow(bm), ncol = 4,              type = \"double\", backingfile = basename(path), backingpath =              dirname(path), descriptorfile = basename(desc) ) pca_scores_stream_bigmatrix(   bm,   scores_fb,   top_pca$rotation[, 1:4],   center = top_pca$center,   scale = top_pca$scale ) #> <pointer: 0x1596ceca0>  # Inspect a lightweight summary without loading the entire matrix colMeans(scores_fb[, 1:2]) #> [1] 3.944992e-17 3.064216e-17 apply(scores_fb[, 1:2], 2, sd) #> [1] 1.141546 1.124998 library(bigmemory) library(bigPCAcpp)  n <- 1000 p <- 25 bm <- bigmemory::big.matrix(n, p, type = \"double\") bm[,] <- matrix(rnorm(n * p), nrow = n)  rotation <- bigmemory::big.matrix(nrow = p, ncol = p) loadings <- bigmemory::big.matrix(nrow = p, ncol = p) correlations <- bigmemory::big.matrix(nrow = p, ncol = p) contrib <- bigmemory::big.matrix(nrow = p, ncol = p)  pca_stream <- pca_stream_bigmatrix(bm, xpRotation = rotation,                                     center = TRUE, scale = FALSE) pca_variable_loadings_stream_bigmatrix(rotation, pca_stream$sdev,                                        loadings) #> <pointer: 0x1596df4e0> pca_variable_correlations_stream_bigmatrix(rotation, pca_stream$sdev,                            pca_stream$column_sd, correlations) #> Error in pca_variable_correlations_stream_bigmatrix(rotation, pca_stream$sdev, : argument \"xpDest\" is missing, with no default pca_variable_contributions_stream_bigmatrix(loadings, contrib) #> <pointer: 0x159655010>"},{"path":"https://fbertran.github.io/bigPCAcpp/index.html","id":"robust-pca-and-singular-value-decompositions","dir":"","previous_headings":"Examples","what":"Robust PCA and singular value decompositions","title":"Principal Component Analysis for bigmemory Matrices","text":"Robust workflows dampen influence outliers retaining familiar PCA interface. pca_robust() helper centres variables median, optionally scales MAD, relies iteratively reweighted SVD derive principal components. robust solver exposed directly via svd_robust() use custom pipelines, streaming-friendly svd_bigmatrix() wrapper computes classical SVDs big.matrix objects without materialising dense copies memory. plot chunk robustsvdexample plot chunk robustsvdexample Robust decompositions -weight contaminated observations classical stream demonstrates fetch singular vectors without materialising dense matrix. robust solver also exposes per-row weights can reused flag problematic observations inspection.","code":"library(bigmemory) library(bigPCAcpp)  set.seed(42) mat <- matrix(rnorm(200), nrow = 40, ncol = 5) mat[1, 1] <- 15  # introduce an outlier mat_scaled <- scale(mat, center = TRUE, scale=TRUE)  # Classical PCA on the same data highlights the impact of the outlier bm_small <- bigmemory::big.matrix(nrow = nrow(mat_scaled), ncol = ncol(mat_scaled), type = \"double\") bm_small[,] <- mat_scaled classical <- pca_bigmatrix(bm_small, center = FALSE, scale = FALSE, ncomp = 3) classical$explained_variance #> [1] 0.2940708 0.2332728 0.2031007  scores_classical <- pca_scores_bigmatrix(xpMat = bm_small, rotation = classical$rotation, center = classical$center, classical$scale) scores_classical[1,] #> [1] -4.752614 -1.534966  1.578737  pca_plot_contributions(pca_individual_contributions(scores_classical, classical$sdev)) # Robust PCA keeps the outlier from dominating the rotation robust <- pca_robust(mat_scaled, center = FALSE, scale = FALSE, ncomp = 3) robust$explained_variance #> [1] 0.3633363 0.3509611 0.2857026  robust$scores[1,] #> [1] 1.025663 1.948710 2.095546  pca_plot_contributions(pca_individual_contributions(robust$scores, robust$sdev)) cbind(classical = classical$rotation[1:5, 1], robust = robust$rotation[1:5, 1]) #>       classical     robust #> [1,] -0.5793644 0.01128235 #> [2,] -0.3121420 0.59547597 #> [3,] -0.5716000 0.77399456 #> [4,]  0.4071138 0.18028142 #> [5,]  0.2728298 0.11709868 # Classical SVD on a file-backed big.matrix path <- tempfile(fileext = \".bin\") desc <- paste0(path, \".desc\")  bm <- bigmemory::filebacked.big.matrix(200, 10, type = \"double\", backingfile =        basename(path), backingpath = dirname(path), descriptorfile = basename(desc)) bm[,] <- matrix(rnorm(2000), nrow = 200) svd_stream <- svd_bigmatrix(bm, nu = 3, nv = 3) svd_stream$d #>  [1] 16.66256 15.90085 15.80823 14.84659 13.99062 13.52699 13.06717 12.61343 #>  [9] 12.15871 11.63997  # Direct access to the robust SVD routine svd_out <- svd_robust(mat, ncomp = 3) svd_out$d #> [1] 16.789433  6.178555  5.620833 svd_out$weights[1:6] #> [1] 1 1 1 1 1 1"},{"path":"https://fbertran.github.io/bigPCAcpp/index.html","id":"plotting-diagnostics","dir":"","previous_headings":"Examples","what":"Plotting diagnostics","title":"Principal Component Analysis for bigmemory Matrices","text":"bigPCAcpp bundles plot helpers operate dense matrices big.matrix backends. snippets illustrate call function using results pca_bigmatrix(). instance, pca_plot_scores() helper samples observations draws scatter plot scores chosen pair components, particularly useful need visually assess potential clusters without loading full data set memory. plot chunk plotexamples plot chunk plotexamples plot chunk plotexamples plot chunk plotexamples plot chunk plotexamples","code":"library(bigmemory) library(bigPCAcpp)  set.seed(123) bm <- bigmemory::big.matrix(500, 6, type = \"double\") bm[,] <- matrix(rnorm(500 * 6), nrow = 500) res <- pca_bigmatrix(bm, center = TRUE, scale = TRUE)  # Scree plot of explained variance pca_plot_scree(res) # Scatter plot of sampled scores on PCs 1 and 2 pca_plot_scores(   bm,   res$rotation,   center = res$center,   scale = res$scale,   components = c(1L, 2L),   max_points = 2000L,   seed = 2024 ) # Contribution bar plot for the leading component loadings <- pca_variable_loadings(res$rotation, res$sdev) contrib <- pca_variable_contributions(loadings) pca_plot_contributions(contrib, component = 1L, top_n = 10L) # Correlation circle for the first two components correlations <- pca_variable_correlations(res$rotation, res$sdev,  res$column_sd, res$scale) pca_plot_correlation_circle(correlations, components = c(1L, 2L)) # Biplot combining scores and loadings scores <- res$scores if (is.null(scores)) {   scores <- pca_scores_bigmatrix(bm, res$rotation, center = res$center, scale = res$scale) } pca_plot_biplot(scores, loadings, components = c(1L, 2L))"},{"path":"https://fbertran.github.io/bigPCAcpp/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Principal Component Analysis for bigmemory Matrices","text":"use bigPCAcpp academic work, please cite: Bertrand F. (2025). bigPCAcpp: Principal Component Analysis bigmemory Matrices.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/index.html","id":"maintainer","dir":"","previous_headings":"","what":"Maintainer","title":"Principal Component Analysis for bigmemory Matrices","text":"Maintainer: Frédéric Bertrand frederic.bertrand@lecnam.net questions, bug reports, contributions, please open issue GitHub.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/benchmark_results.html","id":null,"dir":"Reference","previous_headings":"","what":"Benchmark timings for bigPCAcpp methods — benchmark_results","title":"Benchmark timings for bigPCAcpp methods — benchmark_results","text":"dataset summarising wall-clock performance main PCA entry points bigPCAcpp across matrices increasing size. benchmarks compare classical block-based decomposition, streaming variant writes rotations progresses, scalable stochastic PCA implementation, base R stats::prcomp() routine reference.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/benchmark_results.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Benchmark timings for bigPCAcpp methods — benchmark_results","text":"data frame 360 rows 14 columns: dataset Human-readable size label (\"small\", \"medium\", \"large\", \"xlarge\"). rows Number rows simulated matrix. cols Number columns simulated matrix. ncomp Number components requested. method Computation strategy (\"classical\", \"streaming\", \"scalable\", \"prcomp\"). replicate Replication index repeated runs. user_time User CPU time seconds returned base::system.time(). system_time System CPU time seconds. elapsed Elapsed (wall-clock) time seconds. success Logical flag indicating whether run completed without errors. backend Name backend reported result object computation succeeded. iterations Recorded iteration count iterative methods available (otherwise NA). converged Logical convergence flag iterative methods available. error Error message captured failed runs (otherwise NA).","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/benchmark_results.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Benchmark timings for bigPCAcpp methods — benchmark_results","text":"Generated scripts/run_benchmark.R using randomly simulated -memory matrices (file-backed storage).","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/benchmark_results.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Benchmark timings for bigPCAcpp methods — benchmark_results","text":"","code":"data(benchmark_results)"},{"path":"https://fbertran.github.io/bigPCAcpp/reference/bigPCA.html","id":null,"dir":"Reference","previous_headings":"","what":"BigPCA result objects — bigpca","title":"BigPCA result objects — bigpca","text":"Results returned pca_bigmatrix(), pca_stream_bigmatrix(), pca_robust() inherit bigpca class. objects store component standard deviations, rotation/loadings, optional scores recording computational backend produced . Standard S3 generics summary() plot() implemented convenience. bigpca objects lists produced pca_bigmatrix(), pca_stream_bigmatrix(), pca_robust(), related helpers. mirror structure base R's prcomp() outputs tracking additional metadata large-scale streaming computations. #' @seealso pca_bigmatrix(), pca_stream_bigmatrix(), pca_robust(), pca_plot_scree(), pca_plot_scores(), pca_plot_contributions(), pca_plot_correlation_circle(), pca_plot_biplot().","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/bigPCA.html","id":"components","dir":"Reference","previous_headings":"","what":"Components","title":"BigPCA result objects — bigpca","text":"sdev Numeric vector component standard deviations. rotation Numeric matrix whose columns contain variable loadings (principal axes). center, scale Optional numeric vectors describing centring scaling applied variable fitting model. scores Optional numeric matrix principal component scores computed alongside decomposition. column_sd Numeric vector marginal standard deviations input variable. eigenvalues Numeric vector eigenvalues associated retained components. explained_variance, cumulative_variance Numeric vectors summarising fraction variance explained individual components corresponding cumulative totals. covariance Sample covariance matrix used derive components. nobs Number observations used decomposition. class also records computation backend via attr(x, \"backend\"), enabling downstream methods adjust behaviour streamed robust results.","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigPCAcpp/reference/bigPCAcpp-package.html","id":null,"dir":"Reference","previous_headings":"","what":"bigPCAcpp: Principal Component Analysis for bigmemory Matrices — bigPCAcpp-package","title":"bigPCAcpp: Principal Component Analysis for bigmemory Matrices — bigPCAcpp-package","text":"bigPCAcpp package provides high-performance principal component analysis routines work directly bigmemory::big.matrix objects. Data streamed BLAS LAPACK kernels large, file-backed matrices can analysed without materialising dense copies R. Companion helpers compute scores, loadings, correlations, contributions, including streaming variants write results bigmemory::big.matrix destinations used file-based pipelines.","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigPCAcpp/reference/bigPCAcpp-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"bigPCAcpp: Principal Component Analysis for bigmemory Matrices — bigPCAcpp-package","text":"Maintainer: Frederic Bertrand frederic.bertrand@lecnam.net","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/bigPCAcpp-package.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"bigPCAcpp: Principal Component Analysis for bigmemory Matrices — bigPCAcpp-package","text":"","code":"if (FALSE) { # \\dontrun{ library(bigmemory) mat <- as.big.matrix(matrix(rnorm(20), nrow = 5)) result <- pca_bigmatrix(mat) result$sdev } # }"},{"path":"https://fbertran.github.io/bigPCAcpp/reference/new_bigpca_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal constructors and S3 methods for bigPCAcpp results — new_bigpca_result","title":"Internal constructors and S3 methods for bigPCAcpp results — new_bigpca_result","text":"helpers provide light-weight S3 layer around PCA outputs users can interact familiar generics summary() plot().","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/new_bigpca_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal constructors and S3 methods for bigPCAcpp results — new_bigpca_result","text":"","code":"new_bigpca_result(result, backend)"},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_bigalgebra.html","id":null,"dir":"Reference","previous_headings":"","what":"bigalgebra-backed PCA helpers — pca_bigalgebra","title":"bigalgebra-backed PCA helpers — pca_bigalgebra","text":"Variants PCA helpers stream results directly bigmemory::big.matrix objects, enabling file-backed workflows without materialising dense R matrices.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_bigalgebra.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"bigalgebra-backed PCA helpers — pca_bigalgebra","text":"","code":"pca_bigalgebra(   xpMat,   xpRotation = NULL,   center = TRUE,   scale = FALSE,   ncomp = -1L,   block_size = 1024L )  pca_scores_bigalgebra(   xpMat,   xpDest,   rotation,   center,   scale,   ncomp = -1L,   block_size = 1024L )  pca_variable_loadings_bigalgebra(xpRotation, sdev, xpDest)"},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_bigalgebra.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"bigalgebra-backed PCA helpers — pca_bigalgebra","text":"xpRotation Optionally, either bigmemory::big.matrix external pointer referencing destination big.matrix receives rotation matrix. xpDest Either big.matrix external pointer referencing destination big.matrix stores computed quantity. xpLoadings pca_variable_contributions_bigalgebra(), loadings matrix supplied big.matrix external pointer.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_bigalgebra.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"bigalgebra-backed PCA helpers — pca_bigalgebra","text":"pca_bigalgebra(), bigpca object pca_bigmatrix() addition rotation_bigalgebra element referencing populated big.matrix xpRotation supplied. external pointer supplied xpDest, invisibly.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_bigalgebra.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"bigalgebra-backed PCA helpers — pca_bigalgebra","text":"pca_scores_bigalgebra(): Stream PCA scores destination big.matrix. pca_variable_loadings_bigalgebra(): Populate big.matrix objects derived variable diagnostics.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_bigalgebra.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"bigalgebra-backed PCA helpers — pca_bigalgebra","text":"","code":"set.seed(456) mat <- bigmemory::as.big.matrix(matrix(rnorm(30), nrow = 6)) rotation_store <- bigmemory::big.matrix(ncol(mat), ncol(mat), type = \"double\") pca_stream <- pca_bigalgebra(mat, xpRotation = rotation_store, ncomp = 2) #> Error: rotation big.matrix has incompatible dimensions score_store <- bigmemory::big.matrix(nrow(mat), 2, type = \"double\") pca_scores_bigalgebra(mat, score_store, pca_stream$rotation, pca_stream$center,     pca_stream$scale, ncomp = 2) #> Error: object 'pca_stream' not found"},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_bigmatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Principal component analysis for bigmemory::big.matrix inputs — pca_bigmatrix","title":"Principal component analysis for bigmemory::big.matrix inputs — pca_bigmatrix","text":"Perform principal component analysis (PCA) directly bigmemory::big.matrix without copying data R memory. exported helpers mirror structure base R's prcomp() avoiding need materialise large matrices.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_bigmatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Principal component analysis for bigmemory::big.matrix inputs — pca_bigmatrix","text":"","code":"resolve_big_pointer(x, arg, allow_null = FALSE)  pca_scores_bigmatrix(   xpMat,   rotation,   center,   scale,   ncomp = -1L,   block_size = 1024L )  pca_variable_loadings(rotation, sdev)  pca_variable_correlations(rotation, sdev, column_sd, scale = NULL)  pca_variable_contributions(loadings)  pca_individual_contributions(scores, sdev, total_weight = NA_real_)  pca_individual_cos2(scores)  pca_variable_cos2(correlations)  # S3 method for class 'bigpca' summary(object, ...)  # S3 method for class 'summary.bigpca' print(x, digits = max(3, getOption(\"digits\") - 3), ...)  # S3 method for class 'bigpca' plot(   x,   y,   type = c(\"scree\", \"contributions\", \"correlation_circle\", \"biplot\"),   max_components = 25L,   component = 1L,   top_n = 20L,   components = c(1L, 2L),   data = NULL,   draw = TRUE,   ... )"},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_bigmatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Principal component analysis for bigmemory::big.matrix inputs — pca_bigmatrix","text":"x summary.bigpca object. arg Character string naming argument validated. Used construct informative error messages. allow_null Logical flag indicating whether NULL accepted argument. TRUE, NULL input returned unchanged. xpMat Either bigmemory::big.matrix external pointer mat@address references source big.matrix. rotation rotation matrix rotation element returned pca_bigmatrix(). center pca_scores_bigmatrix(), numeric vector column means (optional). scale Optional numeric vector scaling factors returned pca_bigmatrix(). supplied, indicates PCA performed standardised variables. ncomp Number components retain. Use non-positive value keep components returned decomposition. block_size Number rows process per block streaming data BLAS kernels. Larger values improve throughput cost additional memory. sdev numeric vector component standard deviations, typically sdev element pca_bigmatrix(). column_sd numeric vector marginal standard deviation original variable. scale supplied, correlations computed standardised scale without rescaling column_sd. loadings numeric matrix result pca_variable_loadings(). scores pca_individual_contributions() pca_individual_cos2(), numeric matrix component scores rows correspond observations columns components. total_weight Optional positive scalar giving effective number observations use computing contributions. Defaults number rows scores. correlations pca_variable_cos2(), numeric matrix correlations variables components. object bigpca object created pca_bigmatrix(), pca_stream_bigmatrix(), related helpers. ... Additional arguments passed plotting helpers. digits Number significant digits display printing importance metrics. y Currently unused. type plot draw. Options include \"scree\" (variance explained), \"contributions\" (top contributing variables), \"correlation_circle\" (variable correlations selected components), \"biplot\" (joint display scores loadings). max_components Maximum number components display scree plots. component Component index highlight drawing contribution plots. top_n Number variables display contribution plots. components Length-two integer vector selecting components correlation circle biplot views. data Optional data source (matrix, data frame, bigmemory::big.matrix, external pointer) used compute scores biplots x$scores unavailable. draw Logical; FALSE, return data prepared selected plot instead drawing .","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_bigmatrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Principal component analysis for bigmemory::big.matrix inputs — pca_bigmatrix","text":"pca_bigmatrix(), bigpca object mirroring prcomp result elements sdev, rotation, optional center scale vectors, column_sd, eigenvalues, explained_variance, cumulative_variance, sample covariance matrix. object participates S3 generics summary() plot(). numeric matrix scores rows corresponding observations columns retained components. numeric matrix containing variable loadings component. numeric matrix correlations variables components. numeric matrix entry represents contribution variable component. summary.bigpca(), summary.bigpca object containing component importance measures.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_bigmatrix.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Principal component analysis for bigmemory::big.matrix inputs — pca_bigmatrix","text":"pca_scores_bigmatrix(): Project observations principal component space streaming big.matrix. pca_variable_loadings(): Compute variable loadings (covariances original variables components). pca_variable_correlations(): Compute variable-component correlations given column standard deviations. pca_variable_contributions(): Derive relative contribution variable retained components. pca_individual_contributions(): Compute relative contribution individual observations component. pca_individual_cos2(): Compute squared cosine values measuring quality representation individual observations. pca_variable_cos2(): Compute squared cosine values measuring quality representation variables. summary(bigpca): Summarise component importance metrics bigpca result. print(summary.bigpca): Print component importance summary produced summary.bigpca(). plot(bigpca): Visualise PCA diagnostics scree, correlation circle, contribution, biplot displays.","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_bigmatrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Principal component analysis for bigmemory::big.matrix inputs — pca_bigmatrix","text":"","code":"set.seed(123) mat <- bigmemory::as.big.matrix(matrix(rnorm(40), nrow = 10)) pca <- pca_bigmatrix(mat, center = TRUE, scale = TRUE, ncomp = 3) scores <- pca_scores_bigmatrix(mat, pca$rotation, pca$center, pca$scale, ncomp = 3) loadings <- pca_variable_loadings(pca$rotation, pca$sdev) correlations <- pca_variable_correlations(pca$rotation, pca$sdev, pca$column_sd, pca$scale) contributions <- pca_variable_contributions(loadings) list(scores = scores, loadings = loadings, correlations = correlations,      contributions = contributions) #> $scores #>              [,1]        [,2]        [,3] #>  [1,]  0.54325339 -0.91493729 -0.41315014 #>  [2,] -0.77428157 -0.84150780  0.40023111 #>  [3,]  1.77362948  0.79996096  0.05039649 #>  [4,]  0.61761772  0.59591822 -0.57031347 #>  [5,]  0.23218256  0.95503144 -0.72268699 #>  [6,]  2.66813521 -0.45268284  0.33775240 #>  [7,] -0.08448606  0.81203899  1.15087152 #>  [8,] -2.43891736  0.54722825 -0.96050148 #>  [9,] -0.40827305 -1.59689839 -0.36789931 #> [10,] -2.12886032  0.09584844  1.09529988 #>  #> $loadings #>            [,1]       [,2]       [,3] #> [1,]  0.8567704  0.2711956  0.3439932 #> [2,]  0.7678169 -0.5050498  0.3324763 #> [3,] -0.7573969  0.3708264  0.5203357 #> [4,]  0.7581891  0.5754452 -0.2056261 #>  #> $correlations #>            [,1]       [,2]       [,3] #> [1,]  0.8567704  0.2711956  0.3439932 #> [2,]  0.7678169 -0.5050498  0.3324763 #> [3,] -0.7573969  0.3708264  0.5203357 #> [4,]  0.7581891  0.5754452 -0.2056261 #>  #> $contributions #>           [,1]       [,2]       [,3] #> [1,] 0.2969361 0.09224839 0.21836250 #> [2,] 0.2384786 0.31993524 0.20398568 #> [3,] 0.2320498 0.17247851 0.49962661 #> [4,] 0.2325354 0.41533786 0.07802521 #>"},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_plot_biplot.html","id":null,"dir":"Reference","previous_headings":"","what":"PCA biplot helper — pca_plot_biplot","title":"PCA biplot helper — pca_plot_biplot","text":"Combines principal component scores variable loadings single scatter plot. helper accepts standard matrices bigmemory::big.matrix inputs, extracting requested component columns. draw = TRUE, function scales loadings match score ranges, draws optional axes, overlays loading arrows, labels observations requested.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_plot_biplot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PCA biplot helper — pca_plot_biplot","text":"","code":"pca_plot_biplot(   scores,   loadings,   components = c(1L, 2L),   draw = TRUE,   draw_axes = TRUE,   draw_arrows = TRUE,   label_points = FALSE,   ... )"},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_plot_biplot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PCA biplot helper — pca_plot_biplot","text":"scores Matrix bigmemory::big.matrix containing principal component scores observations rows components columns. loadings Matrix bigmemory::big.matrix variable loadings whose columns correspond principal components. components Integer vector length two selecting components display. draw Logical; set FALSE return prepared data without plotting. draw_axes Logical; TRUE, horizontal vertical axes drawn origin. draw_arrows Logical; TRUE, loading arrows rendered. label_points Logical; TRUE, point labels derived row names drawn next scores. ... Additional graphical parameters passed graphics::plot().","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_plot_biplot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"PCA biplot helper — pca_plot_biplot","text":"list containing selected components, extracted scores, original loadings, scaled loadings (loadings_scaled), applied scale_factor. list returned invisibly. draw = TRUE, biplot produced using base graphics.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_plot_contributions.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot variable contributions — pca_plot_contributions","title":"Plot variable contributions — pca_plot_contributions","text":"Highlights variables contribute selected principal component. helper works dense matrices returned pca_variable_contributions() well bigmemory::big.matrix objects via sampling.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_plot_contributions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot variable contributions — pca_plot_contributions","text":"","code":"pca_plot_contributions(   contributions,   component = 1L,   top_n = 20L,   draw = TRUE,   ... )"},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_plot_contributions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot variable contributions — pca_plot_contributions","text":"contributions Contribution matrix rows correspond variables columns components. component Integer index component visualise. top_n Number variables largest absolute contribution include bar plot. draw Logical; set FALSE skip plotting. ... Additional arguments passed barplot().","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_plot_contributions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot variable contributions — pca_plot_contributions","text":"data frame variables contributions returned invisibly. draw = TRUE, bar plot top variables produced.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_plot_correlation_circle.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a PCA correlation circle — pca_plot_correlation_circle","title":"Plot a PCA correlation circle — pca_plot_correlation_circle","text":"Visualises correlation variable pair principal components. variables projected onto unit circle, points near perimeter indicate strong correlation selected components.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_plot_correlation_circle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a PCA correlation circle — pca_plot_correlation_circle","text":"","code":"pca_plot_correlation_circle(   correlations,   components = c(1L, 2L),   labels = NULL,   draw = TRUE,   ... )"},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_plot_correlation_circle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a PCA correlation circle — pca_plot_correlation_circle","text":"correlations Matrix bigmemory::big.matrix containing variable correlations, typically produced pca_variable_correlations(). components Length-two integer vector specifying principal components display. labels Optional character vector specifying labels display variable. NULL, row names correlations used available. draw Logical; set FALSE return prepared coordinates without plotting. ... Additional graphical parameters passed graphics::plot().","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_plot_correlation_circle.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a PCA correlation circle — pca_plot_correlation_circle","text":"data frame variable, PCx, PCy columns representing projected correlations, PCx/PCy correspond requested component indices. data frame returned invisibly.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_plot_scores.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot sampled PCA scores — pca_plot_scores","title":"Plot sampled PCA scores — pca_plot_scores","text":"Streams subset observations PCA rotation plots scores requested components. Sampling keeps drawn subset small graphics remain interpretable even source big matrix contains millions rows.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_plot_scores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot sampled PCA scores — pca_plot_scores","text":"","code":"pca_plot_scores(   x,   rotation,   center = numeric(),   scale = numeric(),   components = c(1L, 2L),   max_points = 5000L,   sample = c(\"uniform\", \"head\"),   seed = NULL,   draw = TRUE,   ... )"},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_plot_scores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot sampled PCA scores — pca_plot_scores","text":"x Either bigmemory::big.matrix, standard matrix, data frame. rotation rotation matrix pca_result$rotation. center Optional centering vector. Use numeric() centering applied. scale Optional scaling vector. Use numeric() scaling applied. components Length-two integer vector selecting principal components display. max_points Maximum number observations sample plot. sample Strategy selecting rows. \"uniform\" draws random sample without replacement, whereas \"head\" takes first max_points rows. seed Optional seed make sampling reproducible. draw Logical; set FALSE skip plotting return sampled scores. ... Additional graphical parameters forwarded plot().","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_plot_scores.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot sampled PCA scores — pca_plot_scores","text":"list containing indices (sampled row indices) scores (corresponding score matrix) returned invisibly. draw = TRUE scatter plot produced.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_plot_scree.html","id":null,"dir":"Reference","previous_headings":"","what":"Scree plot for principal component importance — pca_plot_scree","title":"Scree plot for principal component importance — pca_plot_scree","text":"Displays proportion variance explained leading principal components. function caps number displayed components keep visualization legible high-dimensional problems.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_plot_scree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scree plot for principal component importance — pca_plot_scree","text":"","code":"pca_plot_scree(   pca_result,   max_components = 25L,   cumulative = TRUE,   draw = TRUE,   ... )"},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_plot_scree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scree plot for principal component importance — pca_plot_scree","text":"pca_result list created pca_bigmatrix() pca_stream_bigmatrix() containing standard deviation explained variance elements. max_components Maximum number components display. Defaults 25 available number components, whichever smaller. cumulative Logical flag indicating whether overlay cumulative explained variance line. draw Logical; set FALSE return prepared data without drawing plot (useful testing). ... Additional parameters passed plot().","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_plot_scree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scree plot for principal component importance — pca_plot_scree","text":"list component, explained, cumulative vectors returned invisibly. draw = TRUE, function produces scree plot using base graphics.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_plots.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot PCA diagnostics for big data workflows — pca_plots","title":"Plot PCA diagnostics for big data workflows — pca_plots","text":"helpers visualise results returned pca_bigmatrix() companions without requiring users materialise dense intermediate structures. plotting function optionally samples inputs default output remains responsive even underlying big matrix spans millions observations.","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_robust.html","id":null,"dir":"Reference","previous_headings":"","what":"Robust principal component analysis — pca_robust","title":"Robust principal component analysis — pca_robust","text":"Compute principal component analysis (PCA) using robust measures location scale extreme observations reduced influence resulting components. implementation centres variable median , requested, scales median absolute deviation (MAD) performing iteratively reweighted singular value decomposition -weights observations unusually large reconstruction errors.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_robust.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Robust principal component analysis — pca_robust","text":"","code":"pca_robust(x, center = TRUE, scale = FALSE, ncomp = NULL)"},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_robust.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Robust principal component analysis — pca_robust","text":"x numeric matrix, data frame, object coercible numeric matrix. Missing values supported. center Logical; variables centred median applying PCA? scale Logical; TRUE, variables scaled MAD centring. Scaling requires center = TRUE. ncomp Number components retain. Use NULL non-positive value keep components returned decomposition.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_robust.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Robust principal component analysis — pca_robust","text":"bigpca object mirroring structure pca_bigmatrix() robust estimates location, scale, variance metrics.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_robust.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Robust principal component analysis — pca_robust","text":"","code":"set.seed(42) x <- matrix(rnorm(50), nrow = 10) x[1, 1] <- 25  # outlier robust <- pca_robust(x, ncomp = 2) robust$sdev #> [1] 2.801017 1.603985"},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_spca.html","id":null,"dir":"Reference","previous_headings":"","what":"Scalable principal component analysis via streaming power iterations — pca_spca","title":"Scalable principal component analysis via streaming power iterations — pca_spca","text":"Implements scalable PCA (sPCA) procedure Elgamal et al. (2015), uses block power iterations approximate leading principal components streaming data manageable chunks. algorithm requires matrix-vector products, allowing large matrices processed without materialising full cross-product memory. Implements scalable PCA (sPCA) procedure Elgamal et al. (2015), uses block power iterations approximate leading principal components streaming data manageable chunks. algorithm requires matrix-vector products, allowing large matrices processed without materialising full cross-product memory. Implements scalable PCA (sPCA) procedure Elgamal et al. (2015), uses block power iterations approximate leading principal components streaming data manageable chunks. algorithm requires matrix-vector products, allowing large matrices processed without materialising full cross-product memory.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_spca.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scalable principal component analysis via streaming power iterations — pca_spca","text":"","code":"pca_spca(   x,   ncomp = NULL,   center = TRUE,   scale = FALSE,   block_size = 2048L,   max_iter = 50L,   tol = 1e-04,   seed = NULL,   return_scores = FALSE,   verbose = FALSE )  pca_spca(   x,   ncomp = NULL,   center = TRUE,   scale = FALSE,   block_size = 2048L,   max_iter = 50L,   tol = 1e-04,   seed = NULL,   return_scores = FALSE,   verbose = FALSE )  pca_spca_R(   x,   ncomp = NULL,   center = TRUE,   scale = FALSE,   block_size = 2048L,   max_iter = 50L,   tol = 1e-04,   seed = NULL,   return_scores = FALSE,   verbose = FALSE )  pca_spca(   x,   ncomp = NULL,   center = TRUE,   scale = FALSE,   block_size = 2048L,   max_iter = 50L,   tol = 1e-04,   seed = NULL,   return_scores = FALSE,   verbose = FALSE )  pca_spca_R(   x,   ncomp = NULL,   center = TRUE,   scale = FALSE,   block_size = 2048L,   max_iter = 50L,   tol = 1e-04,   seed = NULL,   return_scores = FALSE,   verbose = FALSE )"},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_spca.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scalable principal component analysis via streaming power iterations — pca_spca","text":"x numeric matrix, data frame, bigmemory::big.matrix, external pointer referencing big.matrix. input processed row-wise blocks large matrices can analysed without creating dense copies R memory. ncomp Number principal components retain. Use NULL non-positive value keep min(nrow(x), ncol(x)) components. center Logical; column means subtracted performing PCA? scale Logical; TRUE, columns scaled unit variance centring. Scaling requires center = TRUE. block_size Number rows stream per block computing column statistics matrix-vector products. max_iter Maximum number block power iterations. tol Convergence tolerance applied Frobenius norm difference successive subspace projectors. seed Optional integer seed used initialise random starting basis. return_scores Logical; TRUE, principal component scores computed final streaming pass data. verbose Logical; TRUE, diagnostic messages describing iteration progress emitted.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_spca.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scalable principal component analysis via streaming power iterations — pca_spca","text":"bigpca object containing approximate PCA solution structure pca_bigmatrix(). result includes component standard deviations, rotation/loadings, optional scores, column statistics, variance summaries. Additional metadata stored attr(result, \"iterations\") (number iterations performed), attr(result, \"tolerance\") (requested tolerance), attr(result, \"converged\") (logical convergence flag). bigpca object containing approximate PCA solution structure pca_bigmatrix(). result includes component standard deviations, rotation/loadings, optional scores, column statistics, variance summaries. Additional metadata stored attr(result, \"iterations\") (number iterations performed), attr(result, \"tolerance\") (requested tolerance), attr(result, \"converged\") (logical convergence flag). bigpca object containing approximate PCA solution structure pca_bigmatrix(). result includes component standard deviations, rotation/loadings, optional scores, column statistics, variance summaries. Additional metadata stored attr(result, \"iterations\") (number iterations performed), attr(result, \"tolerance\") (requested tolerance), attr(result, \"converged\") (logical convergence flag).","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_spca.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Scalable principal component analysis via streaming power iterations — pca_spca","text":"Tarek Elgamal, Maysam Yabandeh, Ashraf Aboulnaga, Waleed Mustafa, Mohamed Hefeeda (2015). sPCA: Scalable Principal Component Analysis Big Data Distributed Platforms. Proceedings 2015 ACM SIGMOD International Conference Management Data. doi:10.1145/2723372.2751520. Tarek Elgamal, Maysam Yabandeh, Ashraf Aboulnaga, Waleed Mustafa, Mohamed Hefeeda (2015). sPCA: Scalable Principal Component Analysis Big Data Distributed Platforms. Proceedings 2015 ACM SIGMOD International Conference Management Data. doi:10.1145/2723372.2751520. Tarek Elgamal, Maysam Yabandeh, Ashraf Aboulnaga, Waleed Mustafa, Mohamed Hefeeda (2015). sPCA: Scalable Principal Component Analysis Big Data Distributed Platforms. Proceedings 2015 ACM SIGMOD International Conference Management Data. doi:10.1145/2723372.2751520.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_stream_bigmatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Streaming big.matrix PCA helpers — pca_stream_bigmatrix","title":"Streaming big.matrix PCA helpers — pca_stream_bigmatrix","text":"Variants PCA helpers stream results directly bigmemory::big.matrix objects, enabling file-backed workflows without materialising dense R matrices.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_stream_bigmatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Streaming big.matrix PCA helpers — pca_stream_bigmatrix","text":"","code":"pca_spca_stream_bigmatrix(   xpMat,   xpRotation = NULL,   center = TRUE,   scale = FALSE,   ncomp = -1L,   block_size = 2048L,   max_iter = 50L,   tol = 1e-04,   seed = NULL,   return_scores = FALSE,   verbose = FALSE )  pca_scores_stream_bigmatrix(   xpMat,   xpDest,   rotation,   center,   scale,   ncomp = -1L,   block_size = 1024L )  pca_variable_loadings_stream_bigmatrix(xpRotation, sdev, xpDest)  pca_variable_correlations_stream_bigmatrix(   xpRotation,   sdev,   column_sd,   scale = NULL,   xpDest )  pca_variable_contributions_stream_bigmatrix(xpLoadings, xpDest)"},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_stream_bigmatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Streaming big.matrix PCA helpers — pca_stream_bigmatrix","text":"xpMat Either bigmemory::big.matrix external pointer mat@address references source big.matrix. xpRotation pca_variable_correlations_stream_bigmatrix(), bigmemory::big.matrix external pointer containing rotation matrix stream . center pca_scores_bigmatrix(), numeric vector column means (optional). scale Optional numeric vector scaling factors returned pca_stream_bigmatrix() pca_bigmatrix(). supplied, correlations reported scaled data without dividing column_sd. ncomp Number components retain. Use non-positive value keep components returned decomposition. block_size Number rows process per block streaming data BLAS kernels. Larger values improve throughput cost additional memory. max_iter Maximum number block power iterations. tol Convergence tolerance applied Frobenius norm difference successive subspace projectors. seed Optional integer seed used initialise random starting basis. return_scores Logical; TRUE, principal component scores computed final streaming pass data. verbose Logical; TRUE, diagnostic messages describing iteration progress emitted. xpDest Either big.matrix external pointer referencing destination big.matrix stores computed quantity. rotation rotation matrix rotation element returned pca_bigmatrix(). sdev numeric vector component standard deviations, typically sdev element pca_bigmatrix(). column_sd numeric vector variable standard deviations used scale correlations PCA performed unscaled data. xpLoadings pca_variable_contributions_stream_bigmatrix(), loadings matrix supplied big.matrix external pointer.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_stream_bigmatrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Streaming big.matrix PCA helpers — pca_stream_bigmatrix","text":"pca_stream_bigmatrix(), bigpca object pca_bigmatrix() addition rotation_stream_bigmatrix element referencing populated big.matrix xpRotation supplied. pca_spca_stream_bigmatrix(), scalable PCA structure pca_spca() optional pointer populated provided. external pointer supplied xpDest, invisibly.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_stream_bigmatrix.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Streaming big.matrix PCA helpers — pca_stream_bigmatrix","text":"pca_scores_stream_bigmatrix(): Stream PCA scores destination big.matrix. pca_variable_loadings_stream_bigmatrix(): Populate big.matrix objects derived variable diagnostics. pca_variable_correlations_stream_bigmatrix(): Stream variable correlations destination big.matrix. pca_variable_contributions_stream_bigmatrix(): Stream variable contributions destination big.matrix.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_stream_bigmatrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Streaming big.matrix PCA helpers — pca_stream_bigmatrix","text":"","code":"set.seed(456) mat <- bigmemory::as.big.matrix(matrix(rnorm(30), nrow = 6)) ncomp <- 2 rotation_store <- bigmemory::big.matrix(ncol(mat), ncomp, type = \"double\") pca_stream <- pca_stream_bigmatrix(mat, xpRotation = rotation_store, ncomp = ncomp) score_store <- bigmemory::big.matrix(nrow(mat), ncomp, type = \"double\") pca_scores_stream_bigmatrix(     mat,     score_store,     pca_stream$rotation,     pca_stream$center,     pca_stream$scale,     ncomp = ncomp ) #> <pointer: 0x1290c8a40> loadings_store <- bigmemory::big.matrix(ncol(mat), ncomp, type = \"double\") pca_variable_loadings_stream_bigmatrix(     pca_stream$rotation_stream_bigmatrix,     pca_stream$sdev,     loadings_store ) #> <pointer: 0x109ff98c0> correlation_store <- bigmemory::big.matrix(ncol(mat), ncomp, type = \"double\") pca_variable_correlations_stream_bigmatrix(     pca_stream$rotation_stream_bigmatrix,     pca_stream$sdev,     pca_stream$column_sd,     pca_stream$scale,     correlation_store ) #> <pointer: 0x109fa1190> contribution_store <- bigmemory::big.matrix(ncol(mat), ncomp, type = \"double\") pca_variable_contributions_stream_bigmatrix(     loadings_store,     contribution_store ) #> <pointer: 0x109f8ff40>"},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_supplementary_individuals.html","id":null,"dir":"Reference","previous_headings":"","what":"Supplementary individual diagnostics — pca_supplementary_individuals","title":"Supplementary individual diagnostics — pca_supplementary_individuals","text":"Compute principal component scores quality metrics supplementary individuals (rows) projected existing PCA solution.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_supplementary_individuals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Supplementary individual diagnostics — pca_supplementary_individuals","text":"","code":"pca_supplementary_individuals(   data,   rotation,   sdev,   center = NULL,   scale = NULL,   total_weight = NA_real_ )"},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_supplementary_individuals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Supplementary individual diagnostics — pca_supplementary_individuals","text":"data Matrix-like object whose rows correspond supplementary individuals columns original variables. rotation Rotation matrix PCA model (e.g. rotation element bigpca result). sdev Numeric vector component standard deviations associated rotation. center Optional numeric vector giving centring applied variable fitting PCA. Defaults zero centring. scale Optional numeric vector describing scaling applied variable fitting PCA. NULL, scaling applied. total_weight Optional positive scalar passed pca_individual_contributions() computing contributions. left NA (default), resulting contributions component normalised sum one across supplementary individuals. Supplying value bypasses normalisation delegates scaling pca_individual_contributions().","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_supplementary_individuals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Supplementary individual diagnostics — pca_supplementary_individuals","text":"list elements scores, contributions, cos2.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_supplementary_variables.html","id":null,"dir":"Reference","previous_headings":"","what":"Supplementary variable diagnostics — pca_supplementary_variables","title":"Supplementary variable diagnostics — pca_supplementary_variables","text":"Compute loadings, correlations, contributions, cos^2 values supplementary variables (columns) given component scores active individuals.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_supplementary_variables.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Supplementary variable diagnostics — pca_supplementary_variables","text":"","code":"pca_supplementary_variables(data, scores, sdev, center = NULL)"},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_supplementary_variables.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Supplementary variable diagnostics — pca_supplementary_variables","text":"data Matrix-like object whose columns correspond supplementary variables measured active individuals. scores Numeric matrix component scores active individuals. sdev Numeric vector component standard deviations associated scores. center Optional numeric vector specifying centring apply supplementary variable. NULL, column means data used.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/pca_supplementary_variables.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Supplementary variable diagnostics — pca_supplementary_variables","text":"list elements loadings, correlations, contributions, cos2.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/prepare_svd_robust_input.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare iteratively reweighted singular value decomposition — prepare_svd_robust_input","title":"Prepare iteratively reweighted singular value decomposition — prepare_svd_robust_input","text":"Internal helper used pca_robust() compute singular value decomposition less sensitive individual rows extreme values. routine alternates computing SVD row-weighted matrix updating weights via Huber-type scheme based reconstruction residuals.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/prepare_svd_robust_input.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare iteratively reweighted singular value decomposition — prepare_svd_robust_input","text":"","code":"prepare_svd_robust_input(x, ncomp, max_iter, tol, huber_k)"},{"path":"https://fbertran.github.io/bigPCAcpp/reference/prepare_svd_robust_input.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare iteratively reweighted singular value decomposition — prepare_svd_robust_input","text":"x Numeric matrix decomposition computed. ncomp Number leading components retain. max_iter Maximum number reweighting iterations. tol Convergence tolerance applied successive changes row weights singular values. huber_k Tuning constant controlling aggressiveness Huber weight function. Larger values -weight fewer observations.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/prepare_svd_robust_input.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare iteratively reweighted singular value decomposition — prepare_svd_robust_input","text":"list containing x, n, p, ncomp, max_iter, tol huber_k.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/svd_bigmatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Singular value decomposition for bigmemory::big.matrix inputs — svd_bigmatrix","title":"Singular value decomposition for bigmemory::big.matrix inputs — svd_bigmatrix","text":"Compute singular value decomposition (SVD) bigmemory::big.matrix without materialising base R matrix. Blocks rows streamed BLAS LAPACK invoked even moderately large matrices can decomposed efficiently.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/svd_bigmatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Singular value decomposition for bigmemory::big.matrix inputs — svd_bigmatrix","text":"","code":"svd_bigmatrix(   xpMat,   nu = -1L,   nv = -1L,   block_size = 1024L,   method = c(\"dgesdd\", \"dgesvd\") )"},{"path":"https://fbertran.github.io/bigPCAcpp/reference/svd_bigmatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Singular value decomposition for bigmemory::big.matrix inputs — svd_bigmatrix","text":"xpMat Either bigmemory::big.matrix external pointer mat@address references source big.matrix. nu Number left singular vectors return. Use negative value request default min(nrow, ncol) vectors zero skip returning u entirely. nv Number right singular vectors return. Use negative value request default min(nrow, ncol) vectors zero skip returning v entirely. block_size Number rows process per block streaming data BLAS kernels. Larger values can improve throughput cost additional temporary memory. method LAPACK backend used compute decomposition. default uses divide--conquer routine dgesdd falls back dgesvd required.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/svd_bigmatrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Singular value decomposition for bigmemory::big.matrix inputs — svd_bigmatrix","text":"list components u, d, v analogous base R's svd() output. nu nv zero corresponding matrix zero columns.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/svd_bigmatrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Singular value decomposition for bigmemory::big.matrix inputs — svd_bigmatrix","text":"","code":"set.seed(42) mat <- bigmemory::as.big.matrix(matrix(rnorm(20), nrow = 5)) svd_res <- svd_bigmatrix(mat, nu = 2, nv = 2) svd_res$d #> [1] 4.319302 3.283675 1.685888 1.091984"},{"path":"https://fbertran.github.io/bigPCAcpp/reference/svd_robust.html","id":null,"dir":"Reference","previous_headings":"","what":"Robust singular value decomposition (C++ backend) — svd_robust","title":"Robust singular value decomposition (C++ backend) — svd_robust","text":"Compute iteratively reweighted SVD using high-performance C++ implementation. interface mirrors svd_robust_R() delegating heavy lifting compiled code.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/svd_robust.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Robust singular value decomposition (C++ backend) — svd_robust","text":"","code":"svd_robust(   x,   ncomp,   max_iter = 25L,   tol = sqrt(.Machine$double.eps),   huber_k = 1.345 )"},{"path":"https://fbertran.github.io/bigPCAcpp/reference/svd_robust.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Robust singular value decomposition (C++ backend) — svd_robust","text":"x Numeric matrix decomposition computed. ncomp Number leading components retain. max_iter Maximum number reweighting iterations. tol Convergence tolerance applied successive changes row weights singular values. huber_k Tuning constant controlling aggressiveness Huber weight function. Larger values -weight fewer observations.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/svd_robust.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Robust singular value decomposition (C++ backend) — svd_robust","text":"list containing left right singular vectors (u v), singular values (d), final row weights (weights), number iterations required convergence (iterations).","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/svd_robust_R.html","id":null,"dir":"Reference","previous_headings":"","what":"Iteratively reweighted singular value decomposition — svd_robust_R","title":"Iteratively reweighted singular value decomposition — svd_robust_R","text":"Internal helper used pca_robust() compute singular value decomposition less sensitive individual rows extreme values. routine alternates computing SVD row-weighted matrix updating weights via Huber-type scheme based reconstruction residuals.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/svd_robust_R.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Iteratively reweighted singular value decomposition — svd_robust_R","text":"","code":"svd_robust_R(   x,   ncomp,   max_iter = 25L,   tol = sqrt(.Machine$double.eps),   huber_k = 1.345 )"},{"path":"https://fbertran.github.io/bigPCAcpp/reference/svd_robust_R.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Iteratively reweighted singular value decomposition — svd_robust_R","text":"x Numeric matrix decomposition computed. ncomp Number leading components retain. max_iter Maximum number reweighting iterations. tol Convergence tolerance applied successive changes row weights singular values. huber_k Tuning constant controlling aggressiveness Huber weight function. Larger values -weight fewer observations.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/reference/svd_robust_R.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Iteratively reweighted singular value decomposition — svd_robust_R","text":"list containing left right singular vectors (u v), singular values (d), final row weights (weights), number iterations required convergence (iterations). structure mirrors base R's base::svd() output additional metadata.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/news/index.html","id":"bigpcacpp-090","dir":"Changelog","previous_headings":"","what":"bigPCAcpp 0.9.0","title":"bigPCAcpp 0.9.0","text":"Added vignettes, readme. Initial CRAN submission.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/news/index.html","id":"bigpcacpp-050","dir":"Changelog","previous_headings":"","what":"bigPCAcpp 0.5.0","title":"bigPCAcpp 0.5.0","text":"Renamed R implementation scalable PCA pca_spca_R() added C++-backed pca_spca() along pca_spca_stream_bigmatrix() bigmemory::big.matrix workflows, retaining block power iteration algorithm Elgamal et al. (2015). Added pca_spca() implementing scalable PCA algorithm Elgamal et al. (2015) streaming block power iterations large matrices.","code":""},{"path":"https://fbertran.github.io/bigPCAcpp/news/index.html","id":"bigpcacpp-010","dir":"Changelog","previous_headings":"","what":"bigPCAcpp 0.1.0","title":"bigPCAcpp 0.1.0","text":"Added iteratively reweighted singular value decomposition backend pca_robust() exposes final row weights iteration count. Implemented compiled svd_robust() helper svd_robust_R() reference implementation.","code":""}]
